It's been two generations since <a href="http://en.wikipedia.org/wiki/Logic_programming">Logic Programming</a> hit the scene with <a href="http://en.wikipedia.org/wiki/Prolog">Prolog</a>. Logic programming is a seductive concept, holding out the promise of <a href="http://en.wikipedia.org/wiki/AI-complete">squaring the circle of Artificial Intelligence</a>.

Each generation of technologists seems to go through a more-less-heavy infatuation with it, investing in a more-or-less serious dalliance. When the affair is over, the lover parts with a mix of disappointments and fruitful spin-offs like <a href="http://en.wikipedia.org/wiki/Automated_theorem_proving">Theorem Proving</a>, <a href="http://en.wikipedia.org/wiki/Knowledge_representation_and_reasoning">Reasoning Over Knowledge</a>, <a href="http://en.wikipedia.org/wiki/Intelligent_agents">Intelligent Agents</a>, the <a href="http://en.wikipedia.org/wiki/Semantic_web">Semantic Web</a>, and more.

In the early 80's, <a href="http://www.investopedia.com/terms/j/japaninc.asp#axzz24IGEl76d">Japan, Inc</a>. lost hundreds of millions on the <a href="http://en.wikipedia.org/wiki/Fifth_generation_computer">Fifth Generation Project</a> building parallel Prolog machines. One aspect of the project's failure was overreach: Prolog was used for every aspect of the computer, including its operating system. Stretching logic programming to fulfill the requirements of imperative programming entailed so many compromises and complexities that even devotés became skeptics in the end.

Ten years later, Prolog, as alluring a courtesan as ever, enticed another application, this time successful, and, ironically enough, in an operating-system kernel. Windows NT has an enormous problem to solve: booting up in the presence of driver conflicts. The problem is enormous because the number of possible hardware and device-driver configurations in a PC is astronomical (or combinatorial, if you prefer, since PCs are built from combinations of independently purchased parts like motherboards, network interface cards, I/O controllers, and more, and each one has multiple possible drivers with idiosyncratic dependencies on other components and drivers). It's infeasible to store a boot-order list for every possible configuration. Instead, conflict information must be stored in a compact list of facts and rules.

Well, anyone who had ever glimpsed the ankle of Prolog knew exactly where to turn, since that's what Prolog does at heart: reason over facts and rules. One of the world's most widely distributed and successful operating systems <a href="http://web.archive.org/web/20040603192757/research.microsoft.com/research/dtg/davidhov/pap.htm">shipped with a public-domain prolog interpreter in the kernel and a script that resolves device-driver conflicts</a>.

The current generation of technologists is hearing the siren song again, this time in the context of ginormous web-based social and knowledge graphs of entities, relationships, intents, plans, and actions. Let's give logic programming another look and see whether our old friend Prolog is still capable or whether new approaches like LINQ and term-rewriting can and should take its place. This is the first post in a series of investigations into alternatives. We'll begin by resurrecting the Prolog interpreter that Windows NT used and recapitulating its samples in other forms, namely with LINQ and with term-rewriting. We'll progress into more modern scenarios such as fantasy sports, choosing constrained entertainment options, and satisfying exotic trading specifications.
